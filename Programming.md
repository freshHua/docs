###闭包

###设计模式Builder
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
抽象的Builder类，为导向者可能要求创建的每一个构件(Part)定义一个操作(接口)。
1.Product：被构造的复杂对象
2.抽象的Builder类，为导向者可能要求创建的每一个构件(Part)定义一个操作(接口)。抽象接口，用来定义创建Product对象的各个组成部 件的操作。
3.Builder接口的具体实现，可以定义多个， 是实际构建Product对象的类，同时会提供一个返回Product的接口。
4.Builder接口的构造者和使用者。

####生产者消费者模式
生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。

###工厂模式
　简单工厂模式是工厂模式中最简单的一种，用比较简单的方式隐藏创建对象的细节，一般只需要告诉工厂类所需要的类型，工厂类就会返回需要的产品类，但客户端看到的只是产品的抽象对象，无需关心到底是返回了哪个子类。客户端唯一需要知道的具体子类就是工厂子类。除了这点，基本是达到了依赖倒转原则的要求。


###声明和定义
声明：用于向程序表明变量的类型和名字。
定义：用于为变量分配存储空间，还可为变量指定初始值。
extern关键字：通过使用extern关键字声明变量名而不定义它。

###inline
inline提高效率，编译器的建议代码直接展开，目的解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题．

inline成员函数，则必须将类定义和成员函数的定义都放在同一个头文件中(或者写在同一个源文件中)，否则编译时无法进行置换(将函数代码的拷贝嵌入到函数调用点)。


###特殊成员函数

编译器会隐式的产生四个函数：缺省构造函数，析构函数，拷贝构造函数 和 拷贝赋值算子.
C::C()
C::~C()
C::C(const C&)
C& operator=(const C&)
C::C( C&&) //转移构造函数
C& operator=( C&&)

典型的未命名对象就是函数的返回值或者类型转换的对象。
###C++11特性
C++11中所有的值必属于左值、将亡值、纯右值三者之一。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。
**右值引用目的**
临时对象非必要的昂贵的拷贝操作
模板函数中按照参数的实际类型进行转发。
特点：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。右值引用的代码可以自由的接管所引用对象的内容
~~~cpp
const int &a = 1;
int &&a = 1;

~~~
**右值特点**
1.右值只能被 const 类型的 reference 所指向，非 const 的引用则是非法的;
2.自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。

###auto
auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。编译时类型推导

###delctype

###nullptr

###constexpr
constexpr 指定符声明可以在**编译时**求得函数或变量的值。
constexpr对象是const的，它需用编译期间已知的值初始化。
constexpr函数在传入编译期已知值作为参数时，会在编译期间生成结果。

constexpr函数限制持有和返回的类型为字面值类型（literal type），字面值类型（literal type），本质上就是一些在编译期间可确定值的类型。

目标:运行时的工作可以迁移到编译期。参与迁移的代码越多，软件运行得越快（但是，编译的时间可能变长）。

###LAMBA
Lambda 表达式就是用于创建匿名函数的。
~~~cpp
[capture list] (parameter list) mutable exception -> return type { function body }
~~~
简化列表
~~~cpp
[capture list] (params list) -> return type {function body}
声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。
[capture list] (params list) {function body}
省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。
[capture list] {function body}
省略了参数列表，类似普通函数中的无参函数。

capture list

[] // 没有定义任何变量。使用未定义变量会导致错误。
[x, &y] // x 以传值方式传入(默认)，y 以引用方式传入。
[&] // 任何被使用到的外部变量皆隐式地以引用方式加以使用。
[=] // 任何被使用到的外部变量皆隐式地以传值方式加以使用。
[&, x] // x 显示地以传值方式加以使用。其余变量以引用方式加以使用。
[=, &z] // z 显示地以引用方式加以使用。其余变量以传值方式加以使用。


~~~
###函数对象
函数对象：定义了调用操作符（）的类对象。
###Friend
友元按类型分为三种：普通非类成员函数作为友元,类的成员函数作为友元，类作为友元。
类作为友元，可以访问原始类的保护成员和私有成员．
友元函数的特点是能够访问类中的私有成员的非成员函数，访问类中的私有成员。友元的作用在于提高程序的运行效率（即减少了类型检查和安全性检查等都需要的时间开销），但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。
###override
指定一个虚函数覆写另一个虚函数。
###finaL
指定派生类不能覆写虚函数，或类不能被继承。







