###设计模式Builder
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
抽象的Builder类，为导向者可能要求创建的每一个构件(Part)定义一个操作(接口)。
1.Product：被构造的复杂对象
2.抽象的Builder类，为导向者可能要求创建的每一个构件(Part)定义一个操作(接口)。抽象接口，用来定义创建Product对象的各个组成部 件的操作。
3.Builder接口的具体实现，可以定义多个， 是实际构建Product对象的类，同时会提供一个返回Product的接口。
4.Builder接口的构造者和使用者。

####生产者消费者模式
生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。

###工厂模式
　简单工厂模式是工厂模式中最简单的一种，用比较简单的方式隐藏创建对象的细节，一般只需要告诉工厂类所需要的类型，工厂类就会返回需要的产品类，但客户端看到的只是产品的抽象对象，无需关心到底是返回了哪个子类。客户端唯一需要知道的具体子类就是工厂子类。除了这点，基本是达到了依赖倒转原则的要求。



###特殊成员函数

编译器会隐式的产生四个函数：缺省构造函数，析构函数，拷贝构造函数 和 拷贝赋值算子.
C::C()
C::~C()
C::C(const C&)
C& operator=(const C&)
C::C( C&&) //转移构造函数
C& operator=( C&&)

典型的未命名对象就是函数的返回值或者类型转换的对象。
###C++11特性
C++11中所有的值必属于左值、将亡值、纯右值三者之一。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。
**右值引用目的**
临时对象非必要的昂贵的拷贝操作
模板函数中按照参数的实际类型进行转发。
特点：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。右值引用的代码可以自由的接管所引用对象的内容
~~~cpp
const int &a = 1;
int &&a = 1;

~~~
**右值特点**
1.右值只能被 const 类型的 reference 所指向，非 const 的引用则是非法的;
2.自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。

###auto
auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。编译时类型推导

###delctype

###nullptr

###constexpr
constexpr 指定符声明可以在**编译时**求得函数或变量的值。
constexpr对象是const的，它需用编译期间已知的值初始化。
constexpr函数在传入编译期已知值作为参数时，会在编译期间生成结果。

constexpr函数限制持有和返回的类型为字面值类型（literal type），字面值类型（literal type），本质上就是一些在编译期间可确定值的类型。

目标:运行时的工作可以迁移到编译期。参与迁移的代码越多，软件运行得越快（但是，编译的时间可能变长）。

###LAMBA
###函数对象
函数对象：定义了调用操作符（）的类对象。
###Friend类
类作为友元，可以访问原始类的保护成员和私有成员．






